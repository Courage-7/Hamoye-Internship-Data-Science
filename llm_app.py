# -*- coding: utf-8 -*-
"""llm-app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19IS2wh4uxwKm_TzdQpFC2E22bL2gFfT-
"""

import numpy as np
import pandas as pd

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

import pandas as pd
import warnings

# Ignore warnings
warnings.filterwarnings('ignore')

# Define file paths
file_paths = [
    '/kaggle/input/acled-conflict-data/USA_Canada_2020_2024_Jun28.csv',
    '/kaggle/input/acled-conflict-data/Africa_1997-2024_Jun28.csv',
    '/kaggle/input/acled-conflict-data/LatinAmerica_2018-2024_Jun28.csv',
    '/kaggle/input/acled-conflict-data/MiddleEast_2015-2024_Jun28.csv',
    '/kaggle/input/acled-conflict-data/Asia-Pacific_2018-2024_Jun28.csv',
    '/kaggle/input/acled-conflict-data/Europe-Central-Asia_2018-2024_Jun28.csv'
]

# Read and combine all datasets into a single dataframe
df = pd.concat((pd.read_csv(file) for file in file_paths), ignore_index=True)

print("Data aggregation complete!")

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
import google.generativeai as genai
import re

# Configure API key for generative AI model
API_KEY = "AIzaSyAHYMNTOgWyM9-1LB9s65iU0qjQc1L-Fio"
genai.configure(api_key=API_KEY)

# Load data
@st.cache_data
def load_data():
    # Replace with your dataset loading code
    df = pd.read_csv('/kaggle/input/preprocessed-acled-conflict-dataset/cleaned_combined_df')
    return df

def preprocess_data(df):
    le = LabelEncoder()
    df['region_encoded'] = le.fit_transform(df['Region'])
    df['event_encoded'] = le.fit_transform(df['event_type'])
    df['log_fatalities'] = np.log1p(df['fatalities'])
    df['region_event_interaction'] = df['region_encoded'] * df['event_encoded']
    X = df[['fatalities', 'log_fatalities', 'event_encoded', 'region_event_interaction']]
    y = df['region_encoded']
    return X, y, le

def train_rf_model(X, y):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)
    rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
    rf_model.fit(X_train_scaled, y_train)
    predictions = rf_model.predict(X_test_scaled)
    return rf_model, X_test_scaled, y_test, predictions

def plot_feature_importance(rf_model, X):
    feature_importance = pd.DataFrame({'feature': X.columns, 'importance': rf_model.feature_importances_}).sort_values('importance', ascending=False)
    plt.figure(figsize=(10, 6))
    sns.barplot(x='importance', y='feature', data=feature_importance)
    plt.title('Feature Importance')
    plt.xlabel('Importance')
    plt.ylabel('Feature')
    for index, value in enumerate(feature_importance['importance']):
        plt.text(value, index, f'{value:.4f}')
    st.pyplot(plt)

def conflict_mitigation_prompt(conflict_type, region):
    return f"""
    Generate a detailed and actionable mitigation strategy for addressing {conflict_type} in the {region}. The strategy should include the following components:

    1. Immediate Response Actions:
       - Specific emergency measures to be taken to ensure immediate safety and stabilization.
       - Roles and responsibilities of key responders (e.g., security forces, medical personnel, humanitarian organizations).

    2. Medium-Term Interventions:
       - Programs and initiatives to address underlying issues and reduce the recurrence of conflict.
       - Steps to rebuild trust and promote reconciliation among affected communities.

    3. Long-Term Prevention Measures:
       - Structural changes and policies to prevent future conflicts.
       - Education and awareness campaigns to foster a culture of peace and non-violence.

    4. Key Stakeholders to Involve:
       - Identification of essential stakeholders (e.g., government agencies, NGOs, community leaders, international organizations).
       - Their roles and contributions to the mitigation efforts.

    5. Potential Challenges in Implementation:
       - Anticipated obstacles and resistance.
       - Strategies to overcome these challenges and ensure the effectiveness of the mitigation plan.

    Note: Ensure the strategies are well-structured, clearly numbered, and provide practical, actionable steps. Avoid using bold or special characters.
    """

def generate_conflict_mitigation_strategy(conflict_type, region):
    model = GenerativeModel("gemini-1.5-flash")
    prompt_text = conflict_mitigation_prompt(conflict_type, region)
    response = model.generate_content(
        prompt_text,
        generation_config={
            "max_output_tokens": 8052,
            "temperature": 0.3,
            "top_p": 1
        },
        stream=False
    )
    new_response = "".join(response.candidates[0].content.parts[0].text)
    new_response = re.sub(r"[\*#]", "", new_response)
    return new_response

# Streamlit app layout
st.title('Conflict Data Analysis and Mitigation Strategies')
st.write("This app analyzes conflict data using a Random Forest model and generates conflict mitigation strategies using a Generative AI model.")

# Load data
df = load_data()

# Preprocess data
X, y, le = preprocess_data(df)

# Train Random Forest model
rf_model, X_test_scaled, y_test, predictions = train_rf_model(X, y)

# Evaluate model
class_labels = [
    "Africa",
    "Asia",
    "Middle East",
    "Latin America",
    "Europe",
    "USA/Canada"
]
st.subheader('Model Evaluation')
st.text(classification_report(y_test, predictions, target_names=class_labels))

# Plot feature importance
st.subheader('Feature Importance')
plot_feature_importance(rf_model, X)

# Generate conflict mitigation strategy
st.subheader('Conflict Mitigation Strategy')
selected_region = st.selectbox('Select Region:', class_labels)
generate_button = st.button('Generate Mitigation Strategy')
if generate_button:
    predicted_conflict_type = le.inverse_transform([np.argmax(np.bincount(y_test[predictions == le.transform([selected_region])[0]]))])[0]
    strategy = generate_conflict_mitigation_strategy(predicted_conflict_type, selected_region)
    st.text_area('Generated Strategy:', value=strategy, height=300)